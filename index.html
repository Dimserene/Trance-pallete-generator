<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title> <!-- Default title -->
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Lato&family=Montserrat&family=Oswald&family=Raleway&family=Merriweather&family=Playfair+Display&family=Abril+Fatface&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Include Spectrum CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css">
    <script>
    // Arrays of color-related and palette terms
    const terms = [
        // Color-related and palette terms
        'Color', 'Hue', 'Tint', 'Shade', 'Tone', 'Glow', 'Prism', 'Dye',
        'Spectrum', 'Gradient', 'Chroma', 'Blend', 'Mix', 'Pigment', 'Swatch',
        'Palette', 'Canvas', 'Brush', 'Stencil', 'Ink', 'Spray', 'Pastel',
        'Contrast', 'Saturation', 'Brightness', 'Vibrance', 'Luminance', 'Opacity',
        'Filter', 'Pixel', 'Splash', 'Stroke', 'Pattern', 'Texture'
    ];
    
    const creatorTerms = [
        'Maker', 'Artist', 'Wizard', 'Tool', 'Lab', 'Studio', 'Crafter',
        'Builder', 'Mixer', 'Editor', 'Painter', 'Master', 'Smith',
        'Guru', 'Sage', 'Pro', 'Ace', 'Chief', 'Maestro', 'Conjurer',
        'Visionary', 'Alchemist', 'Engineer', 'Creator', 'Designer'
    ];
    
    // Array of font families
    const fontFamilies = [
        'Arial, sans-serif',
        'Helvetica, sans-serif',
        'Georgia, serif',
        '"Times New Roman", Times, serif',
        '"Courier New", Courier, monospace',
        'Verdana, sans-serif',
        '"Lucida Console", Monaco, monospace',
        '"Palatino Linotype", "Book Antiqua", Palatino, serif',
        '"Comic Sans MS", cursive, sans-serif',
        '"Trebuchet MS", Helvetica, sans-serif',
        '"Brush Script MT", cursive',
        '"Roboto", sans-serif',
        '"Open Sans", sans-serif',
        '"Lato", sans-serif',
        '"Montserrat", sans-serif',
        '"Oswald", sans-serif',
        '"Raleway", sans-serif',
        '"Merriweather", serif',
        '"Playfair Display", serif',
        '"Abril Fatface", cursive'
    ];
    
    // Maximum title length
    const maxTitleLength = 25; // Adjust as needed for mobile devices
    
    // Function to generate a random title within the length limit
    function generateRandomTitle() {
        let randomTitle = '';
        let attempts = 0;
        const maxAttempts = 10; // Prevent infinite loops
    
        do {
            const randomTerm = terms[Math.floor(Math.random() * terms.length)];
            const randomCreatorTerm = creatorTerms[Math.floor(Math.random() * creatorTerms.length)];
            randomTitle = 'Trance ' + randomTerm + ' ' + randomCreatorTerm;
            attempts++;
        } while (randomTitle.length > maxTitleLength && attempts < maxAttempts);
    
        // If unable to generate a short enough title, truncate it
        if (randomTitle.length > maxTitleLength) {
            randomTitle = randomTitle.substring(0, maxTitleLength - 1) + '…'; // Add ellipsis
        }
    
        return randomTitle;
    }
    
    // Typewriter and rainbow effect variables
    let typewriterText = '';
    let typewriterIndex = 0;
    let typingSpeed = 100; // Milliseconds per character
    
    function typeWriter() {
        if (typewriterIndex < typewriterText.length) {
            let char = typewriterText.charAt(typewriterIndex);
    
            // Calculate the hue for this character (0 to 360 degrees)
            let hue = (typewriterIndex / typewriterText.length) * 360;
            // Use brighter colors by increasing lightness
            let color = `hsl(${hue}, 100%, 90%)`;
    
            // Append the character with a span and color
            document.getElementById("pageTitle").innerHTML += `<span style="color:${color}">${char}</span>`;
    
            typewriterIndex++;
            setTimeout(typeWriter, typingSpeed);
        } else {
            // Remove HTML tags to set the page title
            let plainTextTitle = typewriterText;
            document.title = plainTextTitle;
        }
    }
    
    // Function to set the random title with typewriter, smooth rainbow effect, and random font
    function setRandomTitle() {
        // Generate the random title
        typewriterText = generateRandomTitle();
        typewriterIndex = 0;
        document.getElementById("pageTitle").innerHTML = ''; // Clear existing text
    
        // Select a random font
        const randomFont = fontFamilies[Math.floor(Math.random() * fontFamilies.length)];
    
        // Apply the random font to the pageTitle element
        document.getElementById("pageTitle").style.fontFamily = randomFont;
    
        // Start the typewriter effect
        typeWriter();
    }
    
    // Run the function on page load
    window.onload = setRandomTitle;
    </script>
    <style>
        /* Base CSS Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding-bottom: 60px; /* Add bottom padding to prevent content from being covered */
        }
        h1 {
            text-align: center;
            padding: 0.5em;
            background-color: #374244;
            color: #ffffff;
            margin: 0;
            font-size: 1.5em;
        }
        #colorContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5em;
        }
        .category {
            width: 100%;
            max-width: 1200px;
            margin: 0.5em 0;
            background-color: #ffffff;
            border-radius: 4px;
            box-sizing: border-box;
            padding: 0.5em;
            display: block; /* Ensure block display */
        }
        .category h2 {
            margin: 1em 0 0.5em 0;
            font-size: 1.2em;
            text-align: left;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.25em;
            display: block; /* Ensure block display */
            width: 100%; /* Ensure it takes full width */
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.5em;
        }
        .color-item {
            display: flex;
            flex-direction: column; /* Adjusted to column to include comments */
            align-items: flex-start; /* Align items to the start */
            padding: 0.25em;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .color-name {
            font-size: 0.9em;
            overflow-wrap: break-word; /* Break long words */
            margin-bottom: 0.25em; /* Add margin below for spacing */
            font-weight: bold;
        }
        .color-comment {
            font-size: 0.8em;
            color: #555;
            margin-top: 0.5em; /* Adjusted margin */
        }
        .controls-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls-container > * {
            flex: 0 0 auto;
            margin-right: 0.25em;
            margin-bottom: 0.25em; /* Add margin for wrapping */
        }
        .color-original,
        .arrow,
        .color-picker {
            width: 1.2em;
            height: 1.2em;
        }
        .hex-input {
            width: 5em;
            padding: 0.2em;
            font-size: 0.8em;
            border: 1px solid #cccccc;
            border-radius: 2px;
            /*text-transform: uppercase;*/
        }
        .copy-button,
        .paste-button,
        .reset-button {
            width: 1.2em;
            height: 1.2em;
            background-size: contain;
            background-repeat: no-repeat;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-right: 0.25em;
            background-color: transparent; /* Remove any background color */
        }
        
        .copy-button {
            background-image: url('https://raw.githubusercontent.com/Dimserene/Trance-pallete-generator/main/copy.png');
        }
        
        .paste-button {
            background-image: url('https://raw.githubusercontent.com/Dimserene/Trance-pallete-generator/main/paste.png');
        }
        
        .reset-button {
            background-image: url('https://raw.githubusercontent.com/Dimserene/Trance-pallete-generator/main/reset.png');
        }
        #resetAllButton,
        #exportLuaButton,
        #importTextButton,
        #downloadLuaButton {
            display: inline-block;
            margin: 0.5em;
            padding: 0.5em 1em;
            font-size: 1em;
            background-color: #374244;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #resetAllButton:hover,
        #exportLuaButton:hover,
        #importTextButton:hover,
        #downloadLuaButton:hover {
            background-color: #4f6367;
        }
        #exportLuaOutput {
            width: calc(100% - 1em);
            max-width: 1200px;
            height: 250px;
            margin: 0.5em auto;
            display: block;
            font-family: monospace;
            padding: 0.5em;
            box-sizing: border-box;
            border: 1px solid #cccccc;
            border-radius: 4px;
            resize: vertical;
        }
        /* Styles for the Simple Message */
        #simpleMessage {
            width: calc(100% - 1em);
            max-width: 1200px;
            margin: 0.5em auto;
            background-color: #f9f9f9;
            padding: 1px;
            border-radius: 4px;
            box-sizing: border-box;
            text-align: center;
            font-size: 1em;
            color: #333;
        }
        #simpleMessage code {
            background-color: #e0e0e0;
            padding: 0px 0px;
            border-radius: 3px;
        }
        /* Footer Styles */
        footer {
            text-align: center;
            padding: 5px;
            background-color: #374244;
            color: white;
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
        }
        footer a {
            color: #ffd700;
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }
        /* Style for the "Jump to Top" button inside the footer */
        #scrollTopButton {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 40px; /* Adjust as needed */
            right: 30px;
            z-index: 99;
            font-size: 18px;
            border: none;
            outline: none;
            background-color: #4f6367;
            color: #ffffff;
            cursor: pointer;
            padding: 15px;
            border-radius: 4px;
        }
        
        #scrollTopButton:hover {
            background-color: #555;
        }
        /* Mobile Styles */
        @media (max-width: 600px) {

            .category {
                padding: 0.25em;
                display: block; /* Ensure block display */
            }
            .category h2 {
                font-size: 1em;
                margin: 1em 0 0.25em 0; /* Add top margin */
                padding-bottom: 0.25em;
                display: block; /* Ensure block display */
                width: 100%; /* Ensure it takes full width */
            }
            .color-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.25em;
            }
            .color-item {
                padding: 0.25em;
                align-items: flex-start;
            }
            .color-name {
                font-size: 0.8em;
                margin-bottom: 0.25em;
            }
            .color-comment {
                font-size: 0.7em;
                margin-bottom: 0.25em;
            }
            .controls-container > * {
                margin-right: 0.25em;
                margin-bottom: 0.25em;
            }
            .color-original,
            .arrow,
            .color-picker,
            .reset-button {
                width: 1em;
                height: 1em;
            }
            .hex-input {
                width: 4em;
            }
            #resetAllButton,
            #exportLuaButton,
            #importTextButton,
            #downloadLuaButton {
                margin: 0.25em;
                padding: 0.5em 1em;
            }
            #exportLuaOutput {
                height: 200px;
                margin: 0.25em auto;
            }
            footer {
                padding: 0px;
                font-size: 0.8em;
            }
            /* Adjust the "Jump to Top" button in the footer on mobile */
            #scrollTopButton {
                margin-top: 5px;
                padding: 5px 5px;
            }
            #pageTitle::after {
                content: '';
                display: inline-block;
                width: 3px;
                height: 26px;
                background-color: white;
                margin-left: 2px;
                animation: blink 1s steps(1) infinite;
                vertical-align: center;
            }
            
            @keyframes blink {
                0%, 50% { opacity: 1; }
                50.01%, 100% { opacity: 0; }
            }
            #pageTitle span {
                transition: color 0.5s;
            }
        }
    </style>
</head>
<body>

    <h1 id="pageTitle"></h1> <!-- Default title for heading -->

    <div style="text-align: center;">
        <button id="resetAllButton">Reset All</button>
        <button id="exportLuaButton">Export</button>
        <button id="importTextButton">Import from Text</button>
        <button id="downloadLuaButton">Download Lua File</button>
    </div>
    <textarea id="exportLuaOutput" placeholder="Paste, edit, or export your Lua code here..."></textarea>
        
    <div id="colorContainer"></div>

    <!-- Footer with Trance Mod Link, Credits -->
    <footer>
        <p>
            <a href="https://github.com/MathIsFun0/Trance" target="_blank">Download Trance</a>
                | 
                Page Created by Dimserene
        </p>
    </footer>

    <button id="scrollTopButton" title="Go to top">Top</button>

    <!-- Include jQuery (Spectrum dependency) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Include Spectrum JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
    <!-- Include the browser-ready IIFE build of Luaparse -->
    <script src="https://unpkg.com/luaparse/dist/luaparse.iife.min.js"></script>
    <script>
        // Updated color data with individual comments for array items and display names for categories
        const defaultColorData = [
            {
                key: 'SPLASH',
                value: [
                    { value: 'FE5F55', comment: 'Main menu background, Color 1' },
                    { value: '009DFF', comment: 'Main menu background, Color 2' }
                ],
                comment: 'Title Screen / Boss Screen colors'
            },
            {
                key: 'MULT',
                value: 'FE5F55',
                comment: 'Background Color of the Multiplier half of the score equation'
            },
            {
                key: 'CHIPS',
                value: '009DFF',
                comment: 'Background Color of the Chips half of the score equation'
            },
            {
                key: 'PLASMA',
                value: 'CC73D9',
                comment: 'Background Color of both halves when score is balanced by Plasma Deck'
            },
            {
                key: 'MONEY',
                value: 'F3B958',
                comment: 'Text Color of current Money ($)'
            },
            {
                key: 'XMULT',
                value: 'FE5F55',
                comment: 'Background of Xmult in joker descriptions'
            },
            {
                key: 'FILTER',
                value: 'FF9A00',
                comment: 'Accent Color for Orange text on most jokers, "Eaten!" and "Again!" notifications etc.'
            },
            {
                key: 'BLUE',
                value: '009DFF',
                comment: 'Blue Color: PLAY, Skip Reward (Darkened by BLACK), number of hands, Discord logo'
            },
            {
                key: 'RED',
                value: 'FE5F55',
                comment: 'Red Color: QUIT, number of discards, minus texts, panel borders'
            },
            {
                key: 'GREEN',
                value: '4BC292',
                comment: 'Base Background color'
            },
            {
                key: 'PALE_GREEN',
                value: '56A887',
                comment: 'Base Background accent color'
            },
            {
                key: 'ORANGE',
                value: 'FDA200',
                comment: 'Orange Color: OPTIONS'
            },
            {
                key: 'IMPORTANT',
                value: 'FF9A00',
                comment: 'Accent color of joker cards (such as designated hand), Current Ante and Round number'
            },
            {
                key: 'GOLD',
                value: 'EAC058',
                comment: 'Money when described in a joker description'
            },
            {
                key: 'YELLOW',
                value: 'FFFF00',
                comment: 'Yellow Color'
            },
            {
                key: 'CLEAR',
                value: '00000000',
                comment: 'Transparent color (e.g. glass cards)'
            },
            {
                key: 'WHITE',
                value: 'FFFFFF',
                comment: 'Pure white color, used in important highlights, use with care'
            },
            {
                key: 'PURPLE',
                value: '8867A5',
                comment: 'Purple Color: Tarot cards in description'
            },
            {
                key: 'BLACK',
                value: '374244',
                comment: 'Black Color: main background colors, applied with varying opacity as shader, "X" button'
            },
            {
                key: 'L_BLACK',
                value: '4F6367',
                comment: 'Light Black Color: main background colors'
            },
            {
                key: 'GREY',
                value: '5F7377',
                comment: 'Grey Color'
            },
            {
                key: 'CHANCE',
                value: '4BC292',
                comment: 'Probability Color in descriptions'
            },
            {
                key: 'JOKER_GREY',
                value: 'BFC7D5',
                comment: 'Grey Color for Joker text'
            },
            {
                key: 'VOUCHER',
                value: 'CB724C',
                comment: 'Background for Voucher text'
            },
            {
                key: 'BOOSTER',
                value: '646EB7',
                comment: 'Background for Booster text; MODS button'
            },
            {
                key: 'ETERNAL',
                value: 'C75985',
                comment: 'Background for Eternal text'
            },
            {
                key: 'PERISHABLE',
                value: '4F5DA1',
                comment: 'Background for Perishable text'
            },
            {
                key: 'RENTAL',
                value: 'B18F43',
                comment: 'Background for Rental text'
            },
            {
                key: 'DYN_UI',
                value: [
                    { key: 'MAIN', value: '374244', comment: 'Dynamic UI main color' },
                    { key: 'DARK', value: '374244', comment: 'Dynamic UI dark color' },
                    { key: 'BOSS_MAIN', value: '374244', comment: 'Boss UI main color' },
                    { key: 'BOSS_DARK', value: '374244', comment: 'Boss UI dark color' },
                    { key: 'BOSS_PALE', value: '374244', comment: 'Boss UI pale color' }
                ],
                comment: 'Colors for dynamic UI elements'
            },
            {
                key: 'SO_1',
                value: [
                    { key: 'Hearts', value: 'F03464', comment: 'High contrast Hearts suit' },
                    { key: 'Diamonds', value: 'F06B3F', comment: 'High contrast Diamonds suit' },
                    { key: 'Spades', value: '403995', comment: 'High contrast Spades suit' },
                    { key: 'Clubs', value: '235955', comment: 'High contrast Clubs suit' }
                ],
                comment: 'High contrast suit colors'
            },
            {
                key: 'SO_2',
                value: [
                    { key: 'Hearts', value: 'F83B2F', comment: 'Normal Hearts suit' },
                    { key: 'Diamonds', value: 'E29000', comment: 'Normal Diamonds suit' },
                    { key: 'Spades', value: '4F31B9', comment: 'Normal Spades suit' },
                    { key: 'Clubs', value: '008EE6', comment: 'Normal Clubs suit' }
                ],
                comment: 'Normal suit colors'
            },
            {
                key: 'UI',
                value: [
                    { key: 'TEXT_LIGHT', value: 'FFFFFF', comment: 'Light text' },
                    { key: 'TEXT_DARK', value: '4F6367', comment: 'Dark text' },
                    { key: 'TEXT_INACTIVE', value: '88888899', comment: 'Inactive text' },
                    { key: 'BACKGROUND_LIGHT', value: 'B8D8D8', comment: 'Light background' },
                    { key: 'BACKGROUND_WHITE', value: 'FFFFFF', comment: 'White background' },
                    { key: 'BACKGROUND_DARK', value: '7A9E9F', comment: 'Dark background' },
                    { key: 'BACKGROUND_INACTIVE', value: '666666FF', comment: 'Inactive background' },
                    { key: 'OUTLINE_LIGHT', value: 'D8D8D8', comment: 'Light outline' },
                    { key: 'OUTLINE_LIGHT_TRANS', value: 'D8D8D866', comment: 'Light translucent outline' },
                    { key: 'OUTLINE_DARK', value: '7A9E9F', comment: 'Dark outline' },
                    { key: 'TRANSPARENT_LIGHT', value: 'EEEEEE22', comment: 'Light transparency' },
                    { key: 'TRANSPARENT_DARK', value: '22222222', comment: 'Dark transparency' },
                    { key: 'HOVER', value: '00000055', comment: 'Hover color' }
                ],
                comment: 'UI Text and Background Colors'
            },
            {
                key: 'SET',
                value: [
                    { value: 'CDD9DC', comment: 'Default set color' },
                    { value: 'CDD9DC', comment: 'Enhanced set color' },
                    { value: '424E54', comment: 'Joker set color' },
                    { value: '424E54', comment: 'Tarot set color' },
                    { value: '424E54', comment: 'Planet set color' },
                    { value: '424E54', comment: 'Spectral set color' },
                    { value: '424E54', comment: 'Voucher set color' }
                ],
                comment: 'Background colors for card sets'
            },
            {
                key: 'SECONDARY_SET',
                value: [
                    { value: '9BB6BDFF', comment: 'Default secondary color' },
                    { value: '8389DDFF', comment: 'Enhanced secondary color' },
                    { value: '708B91', comment: 'Joker secondary color' },
                    { value: 'A782D1', comment: 'Tarot secondary color' },
                    { value: '13AFCE', comment: 'Planet secondary color' },
                    { value: '4584FA', comment: 'Spectral secondary color' },
                    { value: 'FD682B', comment: 'Voucher secondary color' },
                    { value: '4CA893', comment: 'Edition secondary color' }
                ],
                comment: 'Secondary background colors for certain cards'
            },
            {
                key: 'RARITY',
                value: [
                    { value: '009DFF', comment: 'Common' },
                    { value: '4BC292', comment: 'Uncommon' },
                    { value: 'FE5F55', comment: 'Rare' },
                    { value: 'B26CBB', comment: 'Legendary' }
                ],
                comment: 'Rarity colors'
            },
            {
                key: 'BLIND',
                value: [
                    { key: 'Small', value: '50846E', comment: 'Small blind color' },
                    { key: 'Big', value: '50846E', comment: 'Big blind color' },
                    { key: 'Boss', value: 'B44430', comment: 'Boss blind color' },
                    { key: 'won', value: '4F6367', comment: 'Blind won color' }
                ],
                comment: 'Blind colors'
            },
            {
                key: 'HAND_LEVELS',
                value: [
                    { value: 'EFEFEF', comment: 'Hand Level 1' },
                    { value: '95ACFF', comment: 'Hand Level 2' },
                    { value: '65EFAF', comment: 'Hand Level 3' },
                    { value: 'FAE37E', comment: 'Hand Level 4' },
                    { value: 'FFC052', comment: 'Hand Level 5' },
                    { value: 'F87D75', comment: 'Hand Level 6' },
                    { value: 'CAA0EF', comment: 'Hand Level 7+' }
                ],
                comment: 'Hand level progression colors'
            },
            {
                key: 'BACKGROUND',
                value: [
                    { key: 'L', value: 'FFFF00', comment: 'Background Light' },
                    { key: 'D', value: '374244', comment: 'Background Dark' },
                    { key: 'C', value: '374244', comment: 'Background Contrast' }
                ],
                comment: 'Background colors'
            },
            {
                key: 'BOSSES',
                value: [
                    { key: 'bl_ox', value: 'B95B08', comment: 'Boss color for The Ox' },
                    { key: 'bl_hook', value: 'A84024', comment: 'Boss color for The Hook' },
                    { key: 'bl_mouth', value: 'AE718E', comment: 'Boss color for The Mouth' },
                    { key: 'bl_fish', value: '3E85BD', comment: 'Boss color for The Fish' },
                    { key: 'bl_club', value: 'B9CB92', comment: 'Boss color for The Club' },
                    { key: 'bl_manacle', value: '575757', comment: 'Boss color for The Manacle' },
                    { key: 'bl_tooth', value: 'B52D2D', comment: 'Boss color for The Tooth' },
                    { key: 'bl_wall', value: '8A59A5', comment: 'Boss color for The Wall' },
                    { key: 'bl_house', value: '5186A8', comment: 'Boss color for The House' },
                    { key: 'bl_mark', value: '6A3847', comment: 'Boss color for The Mark' },
                    { key: 'bl_wheel', value: '50BF7C', comment: 'Boss color for The Wheel' },
                    { key: 'bl_arm', value: '6865F3', comment: 'Boss color for The Arm' },
                    { key: 'bl_psychic', value: 'EFC03C', comment: 'Boss color for The Psychic' },
                    { key: 'bl_goad', value: 'B95C96', comment: 'Boss color for The Goad' },
                    { key: 'bl_water', value: 'C6E0EB', comment: 'Boss color for The Water' },
                    { key: 'bl_eye', value: '4B71E4', comment: 'Boss color for The Eye' },
                    { key: 'bl_plant', value: '709284', comment: 'Boss color for The Plant' },
                    { key: 'bl_needle', value: '5C6E31', comment: 'Boss color for The Needle' },
                    { key: 'bl_head', value: 'AC9DB4', comment: 'Boss color for The Head' },
                    { key: 'bl_window', value: 'A9A295', comment: 'Boss color for The Window' },
                    { key: 'bl_serpent', value: '439A4F', comment: 'Boss color for The Serpent' },
                    { key: 'bl_pillar', value: '7E6752', comment: 'Boss color for The Pillar' },
                    { key: 'bl_flint', value: 'E56A2F', comment: 'Boss color for The Flint' },
                    { key: 'bl_final_bell', value: '009CFD', comment: 'Boss color for Cerulean Bell' },
                    { key: 'bl_final_leaf', value: '56A786', comment: 'Boss color for Verdant Leaf' },
                    { key: 'bl_final_vessel', value: '8A71E1', comment: 'Boss color for Violet Vessel' },
                    { key: 'bl_final_acorn', value: 'FDA200', comment: 'Boss color for Amber Acorn' },
                    { key: 'bl_final_heart', value: 'AC3232', comment: 'Boss color for Crimson Heart' }
                ],
                comment: 'Boss-specific colors'
            }
        ];

        // Copy of color data that will be modified
        let colorData = JSON.parse(JSON.stringify(defaultColorData));

        // Store references to Spectrum instances
        let spectrumInstances = [];

        // Function to create color pickers using Spectrum
        function createColorPickers(dataArray, container, defaultDataArray) {
            // Clear the container to prevent duplicates
            container.innerHTML = '';
            
            // Reset the spectrumInstances array
            spectrumInstances = [];
            
            const mainCategory = { key: 'Main', items: [] };
            const levelsCategory = { key: 'Levels and Rarity', items: [] };
            const categories = [];

            dataArray.forEach((item, index) => {
                const key = item.key;
                const value = item.value;
                const comment = item.comment || '';
                const defaultItem = defaultDataArray ? defaultDataArray[index] : null;

                if (key === 'RARITY' || key === 'HAND_LEVELS') {
                    // Group RARITY and HAND_LEVELS under "Levels and Rarity"
                    levelsCategory.items.push({
                        key: key,
                        value: value,
                        comment: comment,
                        dataArray: dataArray,
                        dataIndex: index,
                        defaultValue: defaultItem ? defaultItem.value : value
                    });
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object' && value[0].hasOwnProperty('value')) {
                    // Nested category with array of objects
                    categories.push({
                        key: key,
                        value: value,
                        comment: comment,
                        defaultValue: defaultItem ? defaultItem.value : []
                    });
                } else {
                    // Unclassified color or array of colors
                    mainCategory.items.push({
                        key: key,
                        value: value,
                        comment: comment,
                        dataArray: dataArray,
                        dataIndex: index,
                        defaultValue: defaultItem ? defaultItem.value : value
                    });
                }
            });

            // Display Main category if it has items
            if (mainCategory.items.length > 0) {
                createCategoryDiv(mainCategory, container);
            }

            // Display Levels and Rarity category if it has items
            if (levelsCategory.items.length > 0) {
                createCategoryDiv(levelsCategory, container);
            }

            // Now process other categories
            categories.forEach(category => {
                const defaultSubData = category.defaultValue;

                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';

                const categoryTitle = document.createElement('h2');
                categoryTitle.textContent = category.displayName || category.key;
                categoryDiv.appendChild(categoryTitle);

                const colorGrid = document.createElement('div');
                colorGrid.className = 'color-grid';

                category.value.forEach((subItem, subIndex) => {
                    const subKey = subItem.key || `${category.key}[${subIndex}]`;
                    const subValue = subItem.value;
                    const subComment = subItem.comment || '';
                    const defaultSubItem = defaultSubData ? defaultSubData[subIndex] : null;

                    if (typeof subValue === 'string') {
                        const defaultColorValue = defaultSubItem ? defaultSubItem.value || 'FFFFFF' : 'FFFFFF';
                        createColorItem(subValue, subKey, category.value, subIndex, colorGrid, defaultColorValue, subComment);
                    }
                });

                categoryDiv.appendChild(colorGrid);
                container.appendChild(categoryDiv);
            });
        }

        function createCategoryDiv(categoryObj, container) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category';

            const categoryTitle = document.createElement('h2');
            categoryTitle.textContent = categoryObj.displayName || categoryObj.key;
            categoryDiv.appendChild(categoryTitle);

            const colorGrid = document.createElement('div');
            colorGrid.className = 'color-grid';

            categoryObj.items.forEach(item => {
                if (Array.isArray(item.value) && item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('value')) {
                    // Array of objects with value and comment
                    const defaultArrayData = item.defaultValue || [];
                    item.value.forEach((colorItem, idx) => {
                        const colorValue = colorItem.value;
                        const subComment = colorItem.comment || '';
                        const defaultColorValue = defaultArrayData[idx] ? defaultArrayData[idx].value || 'FFFFFF' : 'FFFFFF';
                        const displayName = `${item.key}[${idx}]`;
                        createColorItem(colorValue, displayName, item.value, idx, colorGrid, defaultColorValue, subComment);
                    });
                } else if (typeof item.value === 'string') {
                    // Single color value
                    const defaultColorValue = item.defaultValue || 'FFFFFF';
                    createColorItem(item.value, item.key, item.dataArray, item.dataIndex, colorGrid, defaultColorValue, item.comment);
                }
            });

            categoryDiv.appendChild(colorGrid);
            container.appendChild(categoryDiv);
        }

        function createColorItem(colorValue, displayName, parentDataArray, dataIndex, container, defaultColorValue, comment = '') {
            defaultColorValue = defaultColorValue || 'FFFFFF';
        
            const colorItem = document.createElement('div');
            colorItem.className = 'color-item';
        
            const colorName = document.createElement('div');
            colorName.className = 'color-name';
            colorName.textContent = displayName;
        
            colorItem.appendChild(colorName);
        
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'controls-container';
        
            const colorOriginal = document.createElement('div');
            colorOriginal.className = 'color-original';
            colorOriginal.style.backgroundColor = '#' + defaultColorValue.slice(0, 6);
        
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.textContent = '→';
        
            // Create an input for Spectrum
            const colorInput = document.createElement('input');
            colorInput.type = 'text';
            colorInput.className = 'color-picker';
        
            // Set initial value (including alpha)
            let hexColor = colorValue.slice(0, 6).toUpperCase();
            let alpha = colorValue.length >= 8 ? parseInt(colorValue.slice(6, 8), 16) / 255 : 1;
        
            colorInput.value = '#' + colorValue.slice(0, 6);
        
            const hexInput = document.createElement('input');
            hexInput.type = 'text';
            hexInput.value = colorValue.toUpperCase();
            hexInput.className = 'hex-input';
            hexInput.placeholder = 'Hex/Key';
        
            // Append the colorOriginal, arrow, colorInput, and hexInput to controlsContainer
            controlsContainer.appendChild(colorOriginal);
            controlsContainer.appendChild(arrow);
            controlsContainer.appendChild(colorInput);
            controlsContainer.appendChild(hexInput);
        
            // Add line break before the buttons for layout
            const lineBreak = document.createElement('br');
            controlsContainer.appendChild(lineBreak);
        
            // Reset Button
            const resetButton = document.createElement('button');
            resetButton.className = 'reset-button';
            resetButton.title = 'Reset to Default';
            resetButton.addEventListener('click', function() {
                resetColor();
            });
        
            // Copy Button
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.title = 'Copy Color';
            copyButton.addEventListener('click', function() {
                navigator.clipboard.writeText(hexInput.value);
            });
        
            // Paste Button
            const pasteButton = document.createElement('button');
            pasteButton.className = 'paste-button';
            pasteButton.title = 'Paste Color';
            pasteButton.addEventListener('click', function() {
                navigator.clipboard.readText().then(text => {
                    // Trim and uppercase the pasted text for consistent formatting
                    const pastedText = text.trim().toUpperCase();
        
                    // Validate the pasted text as a hex color code
                    if (/^[0-9A-F]{6,8}$/.test(pastedText)) {
                        hexInput.value = pastedText;
                        updateColor(pastedText);
                    } else {
                        // If invalid, silently revert to the current hex value without alert
                        hexInput.value = getCurrentHexValue();
                    }
                });
            });
        
            // Append buttons to controlsContainer
            controlsContainer.appendChild(resetButton);
            controlsContainer.appendChild(copyButton);
            controlsContainer.appendChild(pasteButton);
        
            // Append controlsContainer to colorItem
            colorItem.appendChild(controlsContainer);
        
            // Append comment after controlsContainer
            if (comment) {
                const colorComment = document.createElement('div');
                colorComment.className = 'color-comment';
                colorComment.textContent = comment;
                colorItem.appendChild(colorComment);
            }
        
            // Append colorItem to the container
            container.appendChild(colorItem);
        
            // Initialize Spectrum on colorInput
            const spectrumInstance = $(colorInput).spectrum({
                color: '#' + hexColor + (alpha < 1 ? Math.round(alpha * 255).toString(16).padStart(2, '0') : ''),
                showInput: false,
                showInitial: false,
                preferredFormat: "hex8",
                showAlpha: true,
                move: function(tinycolor) {
                    const newHex8 = tinycolor.toHex8String().toUpperCase();
                    hexInput.value = newHex8.slice(1);
                    updateParentData(newHex8.slice(1));
                },
                change: function(tinycolor) {
                    const newHex8 = tinycolor.toHex8String().toUpperCase();
                    hexInput.value = newHex8.slice(1);
                    updateParentData(newHex8.slice(1));
                }
            });
        
            spectrumInstances.push({
                spectrumInstance: spectrumInstance,
                colorInput: colorInput,
                hexInput: hexInput,
                parentDataArray: parentDataArray,
                dataIndex: dataIndex,
                defaultColorValue: defaultColorValue
            });
        
            // Helper functions
            function updateParentData(newColor) {
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        parentDataArray[dataIndex].value = newColor;
                    } else {
                        parentDataArray[dataIndex] = newColor;
                    }
                } else {
                    parentDataArray.value = newColor;
                }
            }
        
            function updateColor(newColor) {
                if (/^[0-9A-Fa-f]{6,8}$/.test(newColor)) {
                    let upperHex = newColor.toUpperCase();
                    $(colorInput).spectrum("set", '#' + upperHex);
                    updateParentData(upperHex);
                    hexInput.value = upperHex;
                }
            }
        
            function resetColor() {
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        parentDataArray[dataIndex].value = defaultColorValue;
                    } else {
                        parentDataArray[dataIndex] = defaultColorValue;
                    }
                } else {
                    parentDataArray.value = defaultColorValue;
                }
                $(colorInput).spectrum("set", '#' + defaultColorValue);
                hexInput.value = defaultColorValue.toUpperCase();
            }
        
            function getCurrentHexValue() {
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        return parentDataArray[dataIndex].value;
                    } else {
                        return parentDataArray[dataIndex];
                    }
                } else {
                    return parentDataArray.value;
                }
            }
        
            // Helper function to check if input is a valid keyword
            function isValidKeyword(input) {
                let key = input.startsWith('$') ? input.substring(1) : input;
                key = key.trim();
                return doesKeyExist(key);
            }
                    
        }
        // Initialize the color pickers
        const colorContainer = document.getElementById('colorContainer');
        createColorPickers(colorData, colorContainer, defaultColorData);

        // Reset All functionality
        document.getElementById('resetAllButton').addEventListener('click', function() {
            colorData = JSON.parse(JSON.stringify(defaultColorData));
            createColorPickers(colorData, document.getElementById('colorContainer'), defaultColorData);
        });

        // Export to Lua functionality
        document.getElementById('exportLuaButton').addEventListener('click', function() {
            const exportedLua = 'return ' + convertToLuaTable(colorData);
            document.getElementById('exportLuaOutput').value = exportedLua;
        });

        // Download Lua File functionality
        document.getElementById('downloadLuaButton').addEventListener('click', function() {
            const luaData = 'return ' + convertToLuaTable(colorData);
            const blob = new Blob([luaData], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'New_Theme.lua';
            link.click();
        });

        // Function to convert the array-based color data to Lua table format
        function convertToLuaTable(dataArray, indent = '', isRoot = true) {
            let lua = isRoot ? '{\n' : '{\n';
            const indent2 = indent + '    ';
            dataArray.forEach(item => {
                const key = item.key;
                const value = item.value;
                lua += indent2;
                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
                    lua += key + ' = ';
                } else {
                    lua += '["' + key + '"] = ';
                }
                if (Array.isArray(value)) {
                    if (value.length > 0 && typeof value[0] === 'object' && value[0].hasOwnProperty('value')) {
                        // Array of objects with value and comment
                        lua += '{\n';
                        value.forEach(function(val) {
                            lua += indent2 + '    ';
                            if (val.key) {
                                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(val.key)) {
                                    lua += val.key + ' = HEX(\'' + val.value + '\'),\n';
                                } else {
                                    lua += '["' + val.key + '"] = HEX(\'' + val.value + '\'),\n';
                                }
                            } else {
                                lua += 'HEX(\'' + val.value + '\'),\n';
                            }
                        });
                        lua += indent2 + '},\n';
                    } else {
                        lua += '{},\n';
                    }
                } else if (typeof value === 'string') {
                    lua += 'HEX(\'' + value + '\'),\n';
                } else {
                    lua += 'nil,\n';
                }
            });
            lua += indent + '}';
            return lua;
        }

        // Corrected Import from Text functionality
        document.getElementById('importTextButton').addEventListener('click', function() {
            const luaCode = document.getElementById('exportLuaOutput').value;
            try {
                const flattenedData = parseLuaPalette(luaCode);
                if (flattenedData) {
                    // Create a new copy of defaultColorData
                    colorData = JSON.parse(JSON.stringify(defaultColorData));
                    // Update colorData with the flattened data
                    updateColorData(colorData, flattenedData);
                    createColorPickers(colorData, document.getElementById('colorContainer'), defaultColorData);
                } else {
                    alert('Failed to import palette. Invalid format.');
                }
            } catch (err) {
                console.error(err);
                alert(`An error occurred while importing the Lua code: ${err.message}`);
            }
        });

            
        // Function to update colorData with the flattened data
        function updateColorData(dataArray, flattenedObj) {
            dataArray.forEach(item => {
                const key = item.key;
                if (flattenedObj.hasOwnProperty(key)) {
                    const value = flattenedObj[key];
                    if (typeof value === 'string') {
                        item.value = value.toUpperCase();
                    }
                } else if (Array.isArray(item.value)) {
                    item.value.forEach((subItem, index) => {
                        let subKey = subItem.key ? `${key}.${subItem.key}` : `${key}[${index}]`;
                        if (flattenedObj.hasOwnProperty(subKey)) {
                            subItem.value = flattenedObj[subKey].toUpperCase();
                        } else if (typeof subItem.value === 'object') {
                            updateNestedColorData(subItem.value, subKey, flattenedObj);
                        }
                    });
                } else if (typeof item.value === 'object') {
                    updateNestedColorData(item.value, key, flattenedObj);
                }
            });
        }
        
        function updateNestedColorData(obj, parentKey, flattenedObj) {
            for (let key in obj) {
                let newKey = `${parentKey}.${key}`;
                if (flattenedObj.hasOwnProperty(newKey)) {
                    obj[key] = flattenedObj[newKey].toUpperCase();
                } else if (typeof obj[key] === 'object') {
                    updateNestedColorData(obj[key], newKey, flattenedObj);
                }
            }
        }


        function parseLuaPalette(luaCode) {
            // Remove comments
            luaCode = luaCode.replace(/--.*$/gm, '');
        
            // Remove 'return' keyword and any leading whitespace
            luaCode = luaCode.replace(/^\s*return\s*/, '');
        
            // Replace function calls like HEX('FFFFFF') with string values
            luaCode = luaCode.replace(/HEX\(['"]([0-9A-Fa-f]{6,8})['"]\)/g, '"$1"');
        
            // Replace single quotes with double quotes
            luaCode = luaCode.replace(/'/g, '"');
        
            // Initialize variables
            let index = 0;
            const length = luaCode.length;
        
            // Function to parse the Lua table
            function parseValue() {
                skipWhitespace();
                if (luaCode[index] === '{') {
                    return parseTable();
                } else if (luaCode[index] === '"') {
                    return parseString();
                } else if (/[a-zA-Z_]/.test(luaCode[index])) {
                    return parseIdentifier();
                } else {
                    return parseLiteral();
                }
            }
        
            function parseTable() {
                let isArray = true;
                const result = [];
                index++; // Skip '{'
                skipWhitespace();
        
                while (index < length && luaCode[index] !== '}') {
                    skipWhitespace();
        
                    // Check for key-value pair
                    let startIdx = index;
                    let key = null;
                    if (luaCode[index] === '"') {
                        key = parseString();
                    } else if (/[a-zA-Z_]/.test(luaCode[index])) {
                        key = parseIdentifier();
                    }
        
                    skipWhitespace();
                    if (luaCode[index] === '=' || luaCode[index] === ':') {
                        // This is a key-value pair
                        isArray = false;
                        index++; // Skip '=' or ':'
                        skipWhitespace();
                        const value = parseValue();
                        result.push({ key, value });
                    } else if (key !== null) {
                        // Not a key-value pair, reset index and treat as value
                        index = startIdx;
                        const value = parseValue();
                        result.push(value);
                    } else {
                        // Parse value directly
                        const value = parseValue();
                        result.push(value);
                    }
        
                    skipWhitespace();
                    if (luaCode[index] === ',') {
                        index++; // Skip ','
                        skipWhitespace();
                    } else {
                        break;
                    }
                }
        
                if (luaCode[index] === '}') {
                    index++; // Skip '}'
                    if (isArray) {
                        return result;
                    } else {
                        const obj = {};
                        result.forEach(item => {
                            if (item.key !== undefined) {
                                obj[item.key] = item.value;
                            } else {
                                throw new Error('Invalid table structure');
                            }
                        });
                        return obj;
                    }
                } else {
                    throw new Error(`Expected '}' at position ${index}`);
                }
            }
        
            function parseIdentifier() {
                let id = '';
                while (index < length && /[a-zA-Z0-9_]/.test(luaCode[index])) {
                    id += luaCode[index++];
                }
                return id;
            }
        
            function parseString() {
                let str = '';
                index++; // Skip opening '"'
                while (index < length && luaCode[index] !== '"') {
                    str += luaCode[index++];
                }
                if (luaCode[index] === '"') {
                    index++; // Skip closing '"'
                    return str;
                } else {
                    throw new Error(`Unterminated string at position ${index}`);
                }
            }
        
            function parseLiteral() {
                let literal = '';
                while (index < length && /[\w\d]/.test(luaCode[index])) {
                    literal += luaCode[index++];
                }
                return literal;
            }
        
            function skipWhitespace() {
                while (index < length && /\s/.test(luaCode[index])) {
                    index++;
                }
            }
        
            // Start parsing
            try {
                const parsedValue = parseValue();
                // Now, we have a JavaScript object representing the Lua table
                let flattened = {};
                flattenObject(parsedValue, '', flattened);
                return flattened;
            } catch (e) {
                console.error('Error parsing Lua code:', e);
                alert(`Failed to parse Lua code: ${e.message}`);
                return null;
            }
        }
        
        // Helper function to flatten the object
        function flattenObject(obj, parentKey, result) {
            if (Array.isArray(obj)) {
                obj.forEach((item, index) => {
                    const newKey = parentKey ? `${parentKey}[${index}]` : `[${index}]`;
                    if (typeof item === 'object' && item !== null) {
                        flattenObject(item, newKey, result);
                    } else {
                        result[newKey] = item;
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                for (let key in obj) {
                    const newKey = parentKey ? `${parentKey}.${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null) {
                        flattenObject(obj[key], newKey, result);
                    } else {
                        result[newKey] = obj[key];
                    }
                }
            }
        }
        
        function flattenColorData(dataArray, parentKey = '', result = {}) {
            dataArray.forEach(item => {
                let currentKey = parentKey ? `${parentKey}.${item.key}` : item.key;
        
                if (Array.isArray(item.value)) {
                    // Check if the array is of objects with 'key' and 'value'
                    if (item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('key')) {
                        // Array of objects with 'key' and 'value'
                        item.value.forEach(subItem => {
                            flattenColorData([subItem], currentKey, result);
                        });
                    } else if (item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('value')) {
                        // Array of objects with 'value' (no 'key')
                        item.value.forEach((subItem, index) => {
                            let subKey = `${currentKey}[${index}]`;
                            if (typeof subItem.value === 'object') {
                                flattenColorData([subItem], subKey, result);
                            } else {
                                result[subKey] = subItem.value;
                            }
                        });
                    } else {
                        // Array of primitive values
                        item.value.forEach((subValue, index) => {
                            let subKey = `${currentKey}[${index}]`;
                            result[subKey] = subValue;
                        });
                    }
                } else if (typeof item.value === 'object' && item.value !== null) {
                    // Value is an object
                    flattenColorData([item.value], currentKey, result);
                } else {
                    // Value is a string or primitive
                    result[currentKey] = item.value;
                }
            });
        
            return result;
        }
        
        // Function to convert Lua arrays to JSON arrays
        function convertLuaArrays(luaCode) {
            // This function finds tables without keys and converts them to JSON arrays
        
            // Regex pattern to find tables without keys
            const arrayPattern = /{([\s\S]*?)}/g;
        
            return luaCode.replace(arrayPattern, function(match, content) {
                // Check if the content contains any colons, indicating key-value pairs
                if (/:\s*/.test(content)) {
                    // Contains key-value pairs, keep as object
                    return '{' + content + '}';
                } else {
                    // No key-value pairs, convert to array
                    return '[' + content + ']';
                }
            });
        }
        
        function parseTable(tableNode) {
            const table = {};
        
            tableNode.fields.forEach(field => {
                if (field.type === 'TableKey' || field.type === 'TableKeyString') {
                    const key = parseExpression(field.key);
                    const value = parseExpression(field.value);
                    table[key] = value;
                } else if (field.type === 'TableValue') {
                    // Handle array entries
                    const value = parseExpression(field.value);
                    if (!Array.isArray(table.array)) {
                        table.array = [];
                    }
                    table.array.push(value);
                }
            });
        
            return table;
        }
        
        function parseExpression(node) {
            switch (node.type) {
                case 'StringLiteral':
                    return node.value;
                case 'NumericLiteral':
                    return node.value;
                case 'BooleanLiteral':
                    return node.value;
                case 'TableConstructorExpression':
                    return parseTable(node);
                case 'CallExpression':
                    return parseFunctionCall(node);
                case 'Identifier':
                    return node.name;
                default:
                    return null;
            }
        }
        
        function parseFunctionCall(node) {
            // Assuming function calls are like HEX('FFFFFF')
            if (node.base.type === 'Identifier' && node.base.name === 'HEX') {
                const arg = node.arguments[0];
                if (arg.type === 'StringLiteral') {
                    return arg.value.toUpperCase();
                }
            }
            return null;
        }
        
        // Add the scroll event listener to show/hide the "Top" button
        window.onscroll = function() { scrollFunction(); };
        
        function scrollFunction() {
            const scrollTopButton = document.getElementById("scrollTopButton");
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                scrollTopButton.style.display = "block";
            } else {
                scrollTopButton.style.display = "none";
            }
        }
        
        // "Jump to Top" button functionality
        document.getElementById('scrollTopButton').addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Function to lookup color by key
        function lookupColorByKey(keyPath, useDefault = false) {
            let dataArray = useDefault ? defaultColorData : colorData;
            let flattenedData = flattenColorData(dataArray);
        
            if (flattenedData.hasOwnProperty(keyPath)) {
                return flattenedData[keyPath];
            } else {
                return null;
            }
        }
        
        // Recursive function to find color in data array
        function findColorInDataArray(dataArray, key) {
            for (let item of dataArray) {
                if (item.key && item.key.toUpperCase() === key) {
                    if (typeof item.value === 'string') {
                        return item.value;
                    } else if (Array.isArray(item.value)) {
                        // If the value is an array, you might decide how to handle it
                        // For simplicity, return null or handle nested keys
                        continue;
                    }
                } else if (Array.isArray(item.value)) {
                    // Check within nested arrays
                    let result = findColorInValueArray(item.value, key);
                    if (result) {
                        return result;
                    }
                }
            }
            return null;
        }
        
        // Function to find color in value array
        function findColorInValueArray(valueArray, key) {
            for (let val of valueArray) {
                if (val.key && val.key.toUpperCase() === key) {
                    if (typeof val.value === 'string') {
                        return val.value;
                    }
                }
            }
            return null;
        }
        
        // Function to check if a key exists
        function doesKeyExist(keyPath) {
            return lookupColorByKey(keyPath, true) !== null || lookupColorByKey(keyPath, false) !== null;
        }
        
        function parseKeyPath(keyPath) {
            // Split by '.' to separate nested keys
            let parts = keyPath.split('.');
            let keys = [];
            for (let part of parts) {
                // Handle indices in square brackets
                let regex = /([^\[|\]]+)(\[\d+\])*/g;
                let match;
                while ((match = regex.exec(part)) !== null) {
                    let key = match[1];
                    keys.push(key);
                    if (match[2]) {
                        let indices = match[2].match(/\d+/g).map(Number);
                        keys.push(...indices);
                    }
                }
            }
            return keys.length > 0 ? keys : null;
        }

        function findColorByKeyPath(data, keys) {
            if (!data || keys.length === 0) {
                if (typeof data === 'object' && data.value && typeof data.value === 'string') {
                    return data.value;
                }
                return null;
            }
        
            let key = keys[0];
            let remainingKeys = keys.slice(1);
        
            if (Array.isArray(data)) {
                if (typeof key === 'number') {
                    // Key is an index
                    if (data[key]) {
                        return findColorByKeyPath(data[key], remainingKeys);
                    } else {
                        return null;
                    }
                } else {
                    // Key is a string, find object with matching key
                    for (let item of data) {
                        if (item.key === key) {
                            return findColorByKeyPath(item, remainingKeys);
                        }
                    }
                    return null;
                }
            } else if (typeof data === 'object') {
                if (data.key === key) {
                    if (remainingKeys.length === 0 && typeof data.value === 'string') {
                        // Found the color value
                        return data.value;
                    } else if (data.value) {
                        return findColorByKeyPath(data.value, remainingKeys);
                    }
                } else if (data.value && typeof data.value === 'object') {
                    return findColorByKeyPath(data.value, keys);
                }
            }
            return null;
        }
    </script>
</body>
</html>
