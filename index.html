<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trance Palette Generator</title> <!-- Default title -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Include Spectrum CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css">
    <script>
        // Array of possible titles
        const titles = [
            "Trance Palette Generator",
            "Trance Theme Maker",
            "Trance Palette Creator",
            "Trance Color Designer",
            "Trance Theme Builder",
            "Trance Shade Generator",
            "Trance Palette Wizard",
            "Trance Theme Customizer",
            "Trance Style Generator",
            "Trance Color Schemer",
            "Trance Theme Designer",
            "Trance Shade Builder",
            "Trance Palette Tool",
            "Trance Hue Designer",
            "Trance Color Toolkit",
            "Trance Style Creator",
            "Trance Theme Wizard",
            "Trance Tint Generator",
            "Trance Shade Customizer",
            "Trance Palette Mixer",
            "Trance Theme Artist",
            "Trance Color Maker",
            "Trance Design Studio",
            "Trance Theme Lab",
            "Trance Hue Creator",
            "Trance Palette Studio",
            "Trance Style Maker",
            "Trance Theme Painter",
            "Trance Shade Artist",
            "Trance Color Blender",
            "Trance Hue Generator",
            "Trance Theme Composer",
            "Trance Palette Designer",
            "Trance Tint Maker",
            "Trance Color Editor",
            "Trance Style Builder",
            "Trance Theme Schemer",
            "Trance Shade Designer",
            "Trance Palette Builder",
            "Trance Color Crafter",
            "Trance Theme Crafter",
            "Trance Hue Maker",
            "Trance Style Editor",
            "Trance Palette Crafter",
            "Trance Shade Schemer",
            "Trance Theme Toolkit",
            "Trance Color Wizard",
            "Trance Palette Editor",
            "Trance Design Creator",
            "Trance Style Wizard",
            "Trance Tint Designer",
            "Trance Theme Blender",
            "Trance Hue Wizard",
            "Trance Shade Mixer",
            "Trance Color Artist",
            "Trance Theme Editor",
            "Trance Palette Crafter",
            "Trance Shade Maker",
            "Trance Hue Builder",
            "Trance Color Creator",
            "Trance Style Schemer",
            "Trance Theme Mixer",
            "Trance Tint Crafter",
            "Trance Color Builder",
            "Trance Design Generator",
            "Trance Style Studio",
            "Trance Hue Editor",
            "Trance Color Schemer",
            "Trance Palette Mixer",
            "Trance Theme Creator",
            "Trance Hue Artist",
            "Trance Tint Builder",
            "Trance Style Composer",
            "Trance Theme Composer",
            "Trance Shade Editor",
            "Trance Palette Crafter",
            "Trance Tint Creator",
            "Trance Style Mixer",
            "Trance Hue Crafter",
            "Trance Palette Wizard",
            "Trance Color Composer",
            "Trance Theme Creator",
            "Trance Shade Builder",
            "Trance Tint Wizard",
            "Trance Design Studio",
            "Trance Color Mixer",
            "Trance Style Painter",
            "Trance Theme Tool",
            "Trance Hue Mixer",
            "Trance Palette Tool",
            "Trance Tint Maker",
            "Trance Color Painter",
            "Trance Shade Wizard",
            "Trance Style Tool",
            "Trance Design Builder",
            "Trance Theme Crafter",
            "Trance Hue Designer",
            "Trance Tint Schemer",
            "Trance Shade Creator",
            "Trance Color Builder"
        ];

        // Function to randomly select a title
        function setRandomTitle() {
            const randomTitle = titles[Math.floor(Math.random() * titles.length)];
            document.title = randomTitle; // Set the page title
            document.getElementById("pageTitle").innerText = randomTitle; // Set the h1 title
        }

        // Run the function on page load
        window.onload = setRandomTitle;
    </script>
    <style>
        /* Base CSS Styles */
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding-bottom: 60px; /* Add bottom padding to prevent content from being covered */
        }
        h1 {
            text-align: center;
            padding: 0.5em;
            background-color: #374244;
            color: #ffffff;
            margin: 0;
            font-size: 1.5em;
        }
        #colorContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5em;
        }
        .category {
            width: 100%;
            max-width: 1200px;
            margin: 0.5em 0;
            background-color: #ffffff;
            border-radius: 4px;
            box-sizing: border-box;
            padding: 0.5em;
            display: block; /* Ensure block display */
        }
        .category h2 {
            margin: 1em 0 0.5em 0;
            font-size: 1.2em;
            text-align: left;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.25em;
            display: block; /* Ensure block display */
            width: 100%; /* Ensure it takes full width */
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.5em;
        }
        .color-item {
            display: flex;
            flex-direction: column; /* Adjusted to column to include comments */
            align-items: flex-start; /* Align items to the start */
            padding: 0.25em;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .color-name {
            font-size: 0.9em;
            overflow-wrap: break-word; /* Break long words */
            margin-bottom: 0.25em; /* Add margin below for spacing */
            font-weight: bold;
        }
        .color-comment {
            font-size: 0.8em;
            color: #555;
            margin-top: 0.5em; /* Adjusted margin */
        }
        .controls-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls-container > * {
            flex: 0 0 auto;
            margin-right: 0.25em;
            margin-bottom: 0.25em; /* Add margin for wrapping */
        }
        .color-original,
        .arrow,
        .color-picker {
            width: 1.2em;
            height: 1.2em;
        }
        .hex-input {
            width: 5em;
            padding: 0.2em;
            font-size: 0.8em;
            border: 1px solid #cccccc;
            border-radius: 2px;
            /*text-transform: uppercase;*/
        }
        .reset-button {
            width: 1.2em;
            height: 1.2em;
            background: url('https://raw.githubusercontent.com/Dimserene/Trance-pallete-generator/main/reset.png') no-repeat center;
            background-size: contain;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-right: 0.25em;
        }
        #resetAllButton,
        #exportLuaButton,
        #importTextButton,
        #downloadLuaButton {
            display: inline-block;
            margin: 0.5em;
            padding: 0.5em 1em;
            font-size: 1em;
            background-color: #374244;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #resetAllButton:hover,
        #exportLuaButton:hover,
        #importTextButton:hover,
        #downloadLuaButton:hover {
            background-color: #4f6367;
        }
        #exportLuaOutput {
            width: calc(100% - 1em);
            max-width: 1200px;
            height: 250px;
            margin: 0.5em auto;
            display: block;
            font-family: monospace;
            padding: 0.5em;
            box-sizing: border-box;
            border: 1px solid #cccccc;
            border-radius: 4px;
            resize: vertical;
        }
        /* Styles for the Simple Message */
        #simpleMessage {
            width: calc(100% - 1em);
            max-width: 1200px;
            margin: 0.5em auto;
            background-color: #f9f9f9;
            padding: 1px;
            border-radius: 4px;
            box-sizing: border-box;
            text-align: center;
            font-size: 1em;
            color: #333;
        }
        #simpleMessage code {
            background-color: #e0e0e0;
            padding: 0px 0px;
            border-radius: 3px;
        }
        /* Footer Styles */
        footer {
            text-align: center;
            padding: 5px;
            background-color: #374244;
            color: white;
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
        }
        footer a {
            color: #ffd700;
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }
        /* Style for the "Jump to Top" button inside the footer */
        #scrollTopButton {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 40px; /* Adjust as needed */
            right: 30px;
            z-index: 99;
            font-size: 18px;
            border: none;
            outline: none;
            background-color: #4f6367;
            color: #ffffff;
            cursor: pointer;
            padding: 15px;
            border-radius: 4px;
        }
        
        #scrollTopButton:hover {
            background-color: #555;
        }
        /* Mobile Styles */
        @media (max-width: 600px) {
            .category {
                padding: 0.25em;
                display: block; /* Ensure block display */
            }
            .category h2 {
                font-size: 1em;
                margin: 1em 0 0.25em 0; /* Add top margin */
                padding-bottom: 0.25em;
                display: block; /* Ensure block display */
                width: 100%; /* Ensure it takes full width */
            }
            .color-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.25em;
            }
            .color-item {
                padding: 0.25em;
                align-items: flex-start;
            }
            .color-name {
                font-size: 0.8em;
                margin-bottom: 0.25em;
            }
            .color-comment {
                font-size: 0.7em;
                margin-bottom: 0.25em;
            }
            .controls-container > * {
                margin-right: 0.25em;
                margin-bottom: 0.25em;
            }
            .color-original,
            .arrow,
            .color-picker,
            .reset-button {
                width: 1em;
                height: 1em;
            }
            .hex-input {
                width: 4em;
            }
            #resetAllButton,
            #exportLuaButton,
            #importTextButton,
            #downloadLuaButton {
                margin: 0.25em;
                padding: 0.5em 1em;
            }
            #exportLuaOutput {
                height: 200px;
                margin: 0.25em auto;
            }
            footer {
                padding: 0px;
                font-size: 0.8em;
            }
            /* Adjust the "Jump to Top" button in the footer on mobile */
            #scrollTopButton {
                margin-top: 5px;
                padding: 5px 5px;
            }
        }
    </style>
</head>
<body>

    <h1 id="pageTitle">Trance Palette Generator</h1> <!-- Default title for heading -->

    <div style="text-align: center;">
        <button id="resetAllButton">Reset All</button>
        <button id="exportLuaButton">Export</button>
        <button id="importTextButton">Import from Text</button>
        <button id="downloadLuaButton">Download Lua File</button>
    </div>
    <textarea id="exportLuaOutput" placeholder="Paste, edit, or export your Lua code here..."></textarea>
        
        <!-- Simple Message -->
    <div id="simpleMessage">
        <p>Tip: You can input keys in the hex input field to choose the assigned colors.<br>Add a "$" symbol like "<code>$FILTER</code>" to choose default color.</p>
        <p>
            You can input keys like <code>SPLASH[0]</code> and <code>SO_2.Hearts</code> in the hex input field to choose colors.
            <br>Note: Keys are case-sensitive.
        </p>
    </div>
    <!-- End of Simple Message -->
        
    <div id="colorContainer"></div>

    <!-- Footer with Trance Mod Link, Credits -->
    <footer>
        <p>
            <a href="https://github.com/MathIsFun0/Trance" target="_blank">Download Trance</a>
                | 
                Page Created by Dimserene
        </p>
    </footer>

    <button id="scrollTopButton" title="Go to top">Top</button>

    <!-- Include jQuery (Spectrum dependency) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Include Spectrum JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
    <!-- Include the browser-ready IIFE build of Luaparse -->
    <script src="https://unpkg.com/luaparse/dist/luaparse.iife.min.js"></script>
    <script>
        // Updated color data with individual comments for array items and display names for categories
        const defaultColorData = [
            {
                key: 'SPLASH',
                value: [
                    { value: 'FE5F55', comment: 'Main menu background, Color 1' },
                    { value: '009DFF', comment: 'Main menu background, Color 2' }
                ],
                comment: 'Title Screen / Boss Screen colors'
            },
            {
                key: 'MULT',
                value: 'FE5F55',
                comment: 'Background Color of the Multiplier half of the score equation'
            },
            {
                key: 'CHIPS',
                value: '009DFF',
                comment: 'Background Color of the Chips half of the score equation'
            },
            {
                key: 'PLASMA',
                value: 'CC73D9',
                comment: 'Background Color of both halves when score is balanced by Plasma Deck'
            },
            {
                key: 'MONEY',
                value: 'F3B958',
                comment: 'Text Color of current Money ($)'
            },
            {
                key: 'XMULT',
                value: 'FE5F55',
                comment: 'Background of Xmult in joker descriptions'
            },
            {
                key: 'FILTER',
                value: 'FF9A00',
                comment: 'Accent Color for Orange text on most jokers, "Eaten!" and "Again!" notifications etc.'
            },
            {
                key: 'BLUE',
                value: '009DFF',
                comment: 'Blue Color: PLAY, Skip Reward (Darkened by BLACK), number of hands, Discord logo'
            },
            {
                key: 'RED',
                value: 'FE5F55',
                comment: 'Red Color: QUIT, number of discards, minus texts, panel borders'
            },
            {
                key: 'GREEN',
                value: '4BC292',
                comment: 'Base Background color'
            },
            {
                key: 'PALE_GREEN',
                value: '56A887',
                comment: 'Base Background accent color'
            },
            {
                key: 'ORANGE',
                value: 'FDA200',
                comment: 'Orange Color: OPTIONS'
            },
            {
                key: 'IMPORTANT',
                value: 'FF9A00',
                comment: 'Accent color of joker cards (such as designated hand), Current Ante and Round number'
            },
            {
                key: 'GOLD',
                value: 'EAC058',
                comment: 'Money when described in a joker description'
            },
            {
                key: 'YELLOW',
                value: 'FFFF00',
                comment: 'Yellow Color'
            },
            {
                key: 'CLEAR',
                value: '00000000',
                comment: 'Transparent color (e.g. glass cards)'
            },
            {
                key: 'WHITE',
                value: 'FFFFFF',
                comment: 'Pure white color, used in important highlights, use with care'
            },
            {
                key: 'PURPLE',
                value: '8867A5',
                comment: 'Purple Color: Tarot cards in description'
            },
            {
                key: 'BLACK',
                value: '374244',
                comment: 'Black Color: main background colors, applied with varying opacity as shader, "X" button'
            },
            {
                key: 'L_BLACK',
                value: '4F6367',
                comment: 'Light Black Color: main background colors'
            },
            {
                key: 'GREY',
                value: '5F7377',
                comment: 'Grey Color'
            },
            {
                key: 'CHANCE',
                value: '4BC292',
                comment: 'Probability Color in descriptions'
            },
            {
                key: 'JOKER_GREY',
                value: 'BFC7D5',
                comment: 'Grey Color for Joker text'
            },
            {
                key: 'VOUCHER',
                value: 'CB724C',
                comment: 'Background for Voucher text'
            },
            {
                key: 'BOOSTER',
                value: '646EB7',
                comment: 'Background for Booster text; MODS button'
            },
            {
                key: 'ETERNAL',
                value: 'C75985',
                comment: 'Background for Eternal text'
            },
            {
                key: 'PERISHABLE',
                value: '4F5DA1',
                comment: 'Background for Perishable text'
            },
            {
                key: 'RENTAL',
                value: 'B18F43',
                comment: 'Background for Rental text'
            },
            {
                key: 'DYN_UI',
                value: [
                    { key: 'MAIN', value: '374244', comment: 'Dynamic UI main color' },
                    { key: 'DARK', value: '374244', comment: 'Dynamic UI dark color' },
                    { key: 'BOSS_MAIN', value: '374244', comment: 'Boss UI main color' },
                    { key: 'BOSS_DARK', value: '374244', comment: 'Boss UI dark color' },
                    { key: 'BOSS_PALE', value: '374244', comment: 'Boss UI pale color' }
                ],
                comment: 'Colors for dynamic UI elements'
            },
            {
                key: 'SO_1',
                value: [
                    { key: 'Hearts', value: 'F03464', comment: 'High contrast Hearts suit' },
                    { key: 'Diamonds', value: 'F06B3F', comment: 'High contrast Diamonds suit' },
                    { key: 'Spades', value: '403995', comment: 'High contrast Spades suit' },
                    { key: 'Clubs', value: '235955', comment: 'High contrast Clubs suit' }
                ],
                comment: 'High contrast suit colors'
            },
            {
                key: 'SO_2',
                value: [
                    { key: 'Hearts', value: 'F83B2F', comment: 'Normal Hearts suit' },
                    { key: 'Diamonds', value: 'E29000', comment: 'Normal Diamonds suit' },
                    { key: 'Spades', value: '4F31B9', comment: 'Normal Spades suit' },
                    { key: 'Clubs', value: '008EE6', comment: 'Normal Clubs suit' }
                ],
                comment: 'Normal suit colors'
            },
            {
                key: 'UI',
                value: [
                    { key: 'TEXT_LIGHT', value: 'FFFFFF', comment: 'Light text' },
                    { key: 'TEXT_DARK', value: '4F6367', comment: 'Dark text' },
                    { key: 'TEXT_INACTIVE', value: '88888899', comment: 'Inactive text' },
                    { key: 'BACKGROUND_LIGHT', value: 'B8D8D8', comment: 'Light background' },
                    { key: 'BACKGROUND_WHITE', value: 'FFFFFF', comment: 'White background' },
                    { key: 'BACKGROUND_DARK', value: '7A9E9F', comment: 'Dark background' },
                    { key: 'BACKGROUND_INACTIVE', value: '666666FF', comment: 'Inactive background' },
                    { key: 'OUTLINE_LIGHT', value: 'D8D8D8', comment: 'Light outline' },
                    { key: 'OUTLINE_LIGHT_TRANS', value: 'D8D8D866', comment: 'Light translucent outline' },
                    { key: 'OUTLINE_DARK', value: '7A9E9F', comment: 'Dark outline' },
                    { key: 'TRANSPARENT_LIGHT', value: 'EEEEEE22', comment: 'Light transparency' },
                    { key: 'TRANSPARENT_DARK', value: '22222222', comment: 'Dark transparency' },
                    { key: 'HOVER', value: '00000055', comment: 'Hover color' }
                ],
                comment: 'UI Text and Background Colors'
            },
            {
                key: 'SET',
                value: [
                    { value: 'CDD9DC', comment: 'Default set color' },
                    { value: 'CDD9DC', comment: 'Enhanced set color' },
                    { value: '424E54', comment: 'Joker set color' },
                    { value: '424E54', comment: 'Tarot set color' },
                    { value: '424E54', comment: 'Planet set color' },
                    { value: '424E54', comment: 'Spectral set color' },
                    { value: '424E54', comment: 'Voucher set color' }
                ],
                comment: 'Background colors for card sets'
            },
            {
                key: 'SECONDARY_SET',
                value: [
                    { value: '9BB6BDFF', comment: 'Default secondary color' },
                    { value: '8389DDFF', comment: 'Enhanced secondary color' },
                    { value: '708B91', comment: 'Joker secondary color' },
                    { value: 'A782D1', comment: 'Tarot secondary color' },
                    { value: '13AFCE', comment: 'Planet secondary color' },
                    { value: '4584FA', comment: 'Spectral secondary color' },
                    { value: 'FD682B', comment: 'Voucher secondary color' },
                    { value: '4CA893', comment: 'Edition secondary color' }
                ],
                comment: 'Secondary background colors for certain cards'
            },
            {
                key: 'RARITY',
                value: [
                    { value: '009DFF', comment: 'Common' },
                    { value: '4BC292', comment: 'Uncommon' },
                    { value: 'FE5F55', comment: 'Rare' },
                    { value: 'B26CBB', comment: 'Legendary' }
                ],
                comment: 'Rarity colors'
            },
            {
                key: 'BLIND',
                value: [
                    { key: 'Small', value: '50846E', comment: 'Small blind color' },
                    { key: 'Big', value: '50846E', comment: 'Big blind color' },
                    { key: 'Boss', value: 'B44430', comment: 'Boss blind color' },
                    { key: 'won', value: '4F6367', comment: 'Blind won color' }
                ],
                comment: 'Blind colors'
            },
            {
                key: 'HAND_LEVELS',
                value: [
                    { value: 'EFEFEF', comment: 'Hand Level 1' },
                    { value: '95ACFF', comment: 'Hand Level 2' },
                    { value: '65EFAF', comment: 'Hand Level 3' },
                    { value: 'FAE37E', comment: 'Hand Level 4' },
                    { value: 'FFC052', comment: 'Hand Level 5' },
                    { value: 'F87D75', comment: 'Hand Level 6' },
                    { value: 'CAA0EF', comment: 'Hand Level 7+' }
                ],
                comment: 'Hand level progression colors'
            },
            {
                key: 'BACKGROUND',
                value: [
                    { key: 'L', value: 'FFFF00', comment: 'Background Light' },
                    { key: 'D', value: '374244', comment: 'Background Dark' },
                    { key: 'C', value: '374244', comment: 'Background Contrast' }
                ],
                comment: 'Background colors'
            },
            {
                key: 'BOSSES',
                value: [
                    { key: 'bl_ox', value: 'B95B08', comment: 'Boss color for The Ox' },
                    { key: 'bl_hook', value: 'A84024', comment: 'Boss color for The Hook' },
                    { key: 'bl_mouth', value: 'AE718E', comment: 'Boss color for The Mouth' },
                    { key: 'bl_fish', value: '3E85BD', comment: 'Boss color for The Fish' },
                    { key: 'bl_club', value: 'B9CB92', comment: 'Boss color for The Club' },
                    { key: 'bl_manacle', value: '575757', comment: 'Boss color for The Manacle' },
                    { key: 'bl_tooth', value: 'B52D2D', comment: 'Boss color for The Tooth' },
                    { key: 'bl_wall', value: '8A59A5', comment: 'Boss color for The Wall' },
                    { key: 'bl_house', value: '5186A8', comment: 'Boss color for The House' },
                    { key: 'bl_mark', value: '6A3847', comment: 'Boss color for The Mark' },
                    { key: 'bl_wheel', value: '50BF7C', comment: 'Boss color for The Wheel' },
                    { key: 'bl_arm', value: '6865F3', comment: 'Boss color for The Arm' },
                    { key: 'bl_psychic', value: 'EFC03C', comment: 'Boss color for The Psychic' },
                    { key: 'bl_goad', value: 'B95C96', comment: 'Boss color for The Goad' },
                    { key: 'bl_water', value: 'C6E0EB', comment: 'Boss color for The Water' },
                    { key: 'bl_eye', value: '4B71E4', comment: 'Boss color for The Eye' },
                    { key: 'bl_plant', value: '709284', comment: 'Boss color for The Plant' },
                    { key: 'bl_needle', value: '5C6E31', comment: 'Boss color for The Needle' },
                    { key: 'bl_head', value: 'AC9DB4', comment: 'Boss color for The Head' },
                    { key: 'bl_window', value: 'A9A295', comment: 'Boss color for The Window' },
                    { key: 'bl_serpent', value: '439A4F', comment: 'Boss color for The Serpent' },
                    { key: 'bl_pillar', value: '7E6752', comment: 'Boss color for The Pillar' },
                    { key: 'bl_flint', value: 'E56A2F', comment: 'Boss color for The Flint' },
                    { key: 'bl_final_bell', value: '009CFD', comment: 'Boss color for Cerulean Bell' },
                    { key: 'bl_final_leaf', value: '56A786', comment: 'Boss color for Verdant Leaf' },
                    { key: 'bl_final_vessel', value: '8A71E1', comment: 'Boss color for Violet Vessel' },
                    { key: 'bl_final_acorn', value: 'FDA200', comment: 'Boss color for Amber Acorn' },
                    { key: 'bl_final_heart', value: 'AC3232', comment: 'Boss color for Crimson Heart' }
                ],
                comment: 'Boss-specific colors'
            }
        ];

        // Copy of color data that will be modified
        let colorData = JSON.parse(JSON.stringify(defaultColorData));

        // Store references to Spectrum instances
        let spectrumInstances = [];

        // Function to create color pickers using Spectrum
        function createColorPickers(dataArray, container, defaultDataArray) {
            // Clear the container to prevent duplicates
            container.innerHTML = '';
            
            // Reset the spectrumInstances array
            spectrumInstances = [];
            
            const mainCategory = { key: 'Main', items: [] };
            const levelsCategory = { key: 'Levels and Rarity', items: [] };
            const categories = [];

            dataArray.forEach((item, index) => {
                const key = item.key;
                const value = item.value;
                const comment = item.comment || '';
                const defaultItem = defaultDataArray ? defaultDataArray[index] : null;

                if (key === 'RARITY' || key === 'HAND_LEVELS') {
                    // Group RARITY and HAND_LEVELS under "Levels and Rarity"
                    levelsCategory.items.push({
                        key: key,
                        value: value,
                        comment: comment,
                        dataArray: dataArray,
                        dataIndex: index,
                        defaultValue: defaultItem ? defaultItem.value : value
                    });
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object' && value[0].hasOwnProperty('value')) {
                    // Nested category with array of objects
                    categories.push({
                        key: key,
                        value: value,
                        comment: comment,
                        defaultValue: defaultItem ? defaultItem.value : []
                    });
                } else {
                    // Unclassified color or array of colors
                    mainCategory.items.push({
                        key: key,
                        value: value,
                        comment: comment,
                        dataArray: dataArray,
                        dataIndex: index,
                        defaultValue: defaultItem ? defaultItem.value : value
                    });
                }
            });

            // Display Main category if it has items
            if (mainCategory.items.length > 0) {
                createCategoryDiv(mainCategory, container);
            }

            // Display Levels and Rarity category if it has items
            if (levelsCategory.items.length > 0) {
                createCategoryDiv(levelsCategory, container);
            }

            // Now process other categories
            categories.forEach(category => {
                const defaultSubData = category.defaultValue;

                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';

                const categoryTitle = document.createElement('h2');
                categoryTitle.textContent = category.displayName || category.key;
                categoryDiv.appendChild(categoryTitle);

                const colorGrid = document.createElement('div');
                colorGrid.className = 'color-grid';

                category.value.forEach((subItem, subIndex) => {
                    const subKey = subItem.key || `${category.key}[${subIndex}]`;
                    const subValue = subItem.value;
                    const subComment = subItem.comment || '';
                    const defaultSubItem = defaultSubData ? defaultSubData[subIndex] : null;

                    if (typeof subValue === 'string') {
                        const defaultColorValue = defaultSubItem ? defaultSubItem.value || 'FFFFFF' : 'FFFFFF';
                        createColorItem(subValue, subKey, category.value, subIndex, colorGrid, defaultColorValue, subComment);
                    }
                });

                categoryDiv.appendChild(colorGrid);
                container.appendChild(categoryDiv);
            });
        }

        function createCategoryDiv(categoryObj, container) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category';

            const categoryTitle = document.createElement('h2');
            categoryTitle.textContent = categoryObj.displayName || categoryObj.key;
            categoryDiv.appendChild(categoryTitle);

            const colorGrid = document.createElement('div');
            colorGrid.className = 'color-grid';

            categoryObj.items.forEach(item => {
                if (Array.isArray(item.value) && item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('value')) {
                    // Array of objects with value and comment
                    const defaultArrayData = item.defaultValue || [];
                    item.value.forEach((colorItem, idx) => {
                        const colorValue = colorItem.value;
                        const subComment = colorItem.comment || '';
                        const defaultColorValue = defaultArrayData[idx] ? defaultArrayData[idx].value || 'FFFFFF' : 'FFFFFF';
                        const displayName = `${item.key}[${idx}]`;
                        createColorItem(colorValue, displayName, item.value, idx, colorGrid, defaultColorValue, subComment);
                    });
                } else if (typeof item.value === 'string') {
                    // Single color value
                    const defaultColorValue = item.defaultValue || 'FFFFFF';
                    createColorItem(item.value, item.key, item.dataArray, item.dataIndex, colorGrid, defaultColorValue, item.comment);
                }
            });

            categoryDiv.appendChild(colorGrid);
            container.appendChild(categoryDiv);
        }

        function createColorItem(colorValue, displayName, parentDataArray, dataIndex, container, defaultColorValue, comment = '') {
            // Provide a default value if defaultColorValue is undefined
            defaultColorValue = defaultColorValue || 'FFFFFF';
        
            const colorItem = document.createElement('div');
            colorItem.className = 'color-item';
        
            const colorName = document.createElement('div');
            colorName.className = 'color-name';
            colorName.textContent = displayName;
        
            colorItem.appendChild(colorName);
        
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'controls-container';
        
            const colorOriginal = document.createElement('div');
            colorOriginal.className = 'color-original';
            colorOriginal.style.backgroundColor = '#' + defaultColorValue.slice(0, 6);
        
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            arrow.textContent = '→';
        
            // Create an input for Spectrum
            const colorInput = document.createElement('input');
            colorInput.type = 'text';
            colorInput.className = 'color-picker';
        
            // Set initial value (including alpha)
            let hexColor = colorValue.slice(0, 6).toUpperCase();
            let alpha = colorValue.length >= 8 ? parseInt(colorValue.slice(6, 8), 16) / 255 : 1;
        
            colorInput.value = '#' + colorValue.slice(0, 6);
        
            const hexInput = document.createElement('input');
            hexInput.type = 'text';
            hexInput.value = colorValue.toUpperCase();
            hexInput.className = 'hex-input';
            hexInput.placeholder = 'Hex/Key';
        
            // Reset Button
            const resetButton = document.createElement('button');
            resetButton.className = 'reset-button';
            resetButton.title = 'Reset to Default';
            resetButton.addEventListener('click', function() {
                // Reset data
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        parentDataArray[dataIndex].value = defaultColorValue;
                    } else {
                        parentDataArray[dataIndex] = defaultColorValue;
                    }
                } else {
                    parentDataArray.value = defaultColorValue;
                }
                // Update Spectrum color picker
                const defaultHexColor = defaultColorValue.slice(0, 6).toUpperCase();
                const defaultAlpha = defaultColorValue.length >= 8 ? parseInt(defaultColorValue.slice(6, 8), 16) / 255 : 1;
                const defaultColorString = '#' + defaultHexColor + (defaultAlpha < 1 ? defaultColorValue.slice(6, 8) : '');
                $(colorInput).spectrum("set", defaultColorString);
                // Update hex input
                hexInput.value = defaultColorValue.toUpperCase();
            });
        
            // Append elements to controlsContainer
            controlsContainer.appendChild(colorOriginal);
            controlsContainer.appendChild(arrow);
            controlsContainer.appendChild(colorInput);
            controlsContainer.appendChild(hexInput);
            controlsContainer.appendChild(resetButton);
        
            // Append controlsContainer to colorItem
            colorItem.appendChild(controlsContainer);
        
            // Now append the comment after the controlsContainer
            if (comment) {
                const colorComment = document.createElement('div');
                colorComment.className = 'color-comment';
                colorComment.textContent = comment;
                colorItem.appendChild(colorComment);
            }
        
            // Append the colorItem to the container
            container.appendChild(colorItem);
        
            // Initialize Spectrum on the colorInput
            const spectrumInstance = $(colorInput).spectrum({
                color: '#' + hexColor + (alpha < 1 ? Math.round(alpha * 255).toString(16).padStart(2, '0') : ''),
                showInput: false,
                showInitial: false,
                preferredFormat: "hex8",
                showAlpha: true,
                move: function(tinycolor) {
                    const newHex8 = tinycolor.toHex8String().toUpperCase();
                    hexInput.value = newHex8.slice(1);
                    // Update colorData here on the color move
                    updateParentData(newHex8.slice(1));
                },
                change: function(tinycolor) {
                    const newHex8 = tinycolor.toHex8String().toUpperCase();
                    hexInput.value = newHex8.slice(1);
                    // Update colorData when the color picker changes
                    updateParentData(newHex8.slice(1));
                }
            });
        
            // Store reference for reset all functionality
            spectrumInstances.push({
                spectrumInstance: spectrumInstance,
                colorInput: colorInput,
                hexInput: hexInput,
                parentDataArray: parentDataArray,
                dataIndex: dataIndex,
                defaultColorValue: defaultColorValue
            });
        
            // Update function to modify colorData
            function updateParentData(newColor) {
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        parentDataArray[dataIndex].value = newColor;
                    } else {
                        parentDataArray[dataIndex] = newColor;
                    }
                } else {
                    parentDataArray.value = newColor;
                }
            }
        
            function updateColor(newColor) {
                // Validate hex code or keyword
                if (/^[0-9A-Fa-f]{6,8}$/.test(newColor)) {
                    let upperHex = newColor.toUpperCase();
                    let colorString = '#' + upperHex;
                    $(colorInput).spectrum("set", colorString);
                    updateParentData(upperHex);
                    hexInput.value = upperHex; // Set the input value to uppercase hex code
                } else {
                    // Handle keyword input
                    let isDefault = false;
                    let key = newColor;
                    if (newColor.startsWith('$')) {
                        isDefault = true;
                        key = newColor.substring(1);
                    }
                    key = key.trim(); // Preserve case for key
                    let lookupColor = lookupColorByKey(key, isDefault);
                    if (lookupColor) {
                        $(colorInput).spectrum("set", '#' + lookupColor);
                        hexInput.value = lookupColor; // Preserve case for the color code
                        updateParentData(lookupColor);
                    } else {
                        // If keyword doesn't exist, provide feedback
                        alert(`Key "${newColor}" not found.`);
                        // Reset to previous value
                        let currentHex = getCurrentHexValue();
                        hexInput.value = currentHex;
                    }
                }
            }
            
            hexInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    const newInput = hexInput.value.trim();
                    if (newInput !== '') {
                        updateColor(newInput);
                    }
                }
            });
        
            hexInput.addEventListener('blur', function() {
                const newInput = hexInput.value.trim();
                if (newInput === '') {
                    // If empty, reset to current value
                    let currentHex = getCurrentHexValue();
                    hexInput.value = currentHex;
                } else if (!/^[0-9A-Fa-f]{6,8}$/.test(newInput) && !isValidKeyword(newInput)) {
                    // If invalid, reset to current color value
                    let currentHex = getCurrentHexValue();
                    hexInput.value = currentHex;
                } else if (newInput !== getCurrentHexValue() ){
                    // If valid and different, update the color
                    updateColor(newInput);
                }
            });
        
            // Helper function to get current hex value from parentDataArray
            function getCurrentHexValue() {
                if (Array.isArray(parentDataArray)) {
                    if (typeof parentDataArray[dataIndex] === 'object') {
                        return parentDataArray[dataIndex].value;
                    } else {
                        return parentDataArray[dataIndex];
                    }
                } else {
                    return parentDataArray.value;
                }
            }
        
            // Helper function to check if input is a valid keyword
            function isValidKeyword(input) {
                let key = input.startsWith('$') ? input.substring(1) : input;
                key = key.trim();
                return doesKeyExist(key);
            }
        }
        // Initialize the color pickers
        const colorContainer = document.getElementById('colorContainer');
        createColorPickers(colorData, colorContainer, defaultColorData);

        // Reset All functionality
        document.getElementById('resetAllButton').addEventListener('click', function() {
            colorData = JSON.parse(JSON.stringify(defaultColorData));
            createColorPickers(colorData, document.getElementById('colorContainer'), defaultColorData);
        });

        // Export to Lua functionality
        document.getElementById('exportLuaButton').addEventListener('click', function() {
            const exportedLua = 'return ' + convertToLuaTable(colorData);
            document.getElementById('exportLuaOutput').value = exportedLua;
        });

        // Download Lua File functionality
        document.getElementById('downloadLuaButton').addEventListener('click', function() {
            const luaData = 'return ' + convertToLuaTable(colorData);
            const blob = new Blob([luaData], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'New_Theme.lua';
            link.click();
        });

        // Function to convert the array-based color data to Lua table format
        function convertToLuaTable(dataArray, indent = '', isRoot = true) {
            let lua = isRoot ? '{\n' : '{\n';
            const indent2 = indent + '    ';
            dataArray.forEach(item => {
                const key = item.key;
                const value = item.value;
                lua += indent2;
                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
                    lua += key + ' = ';
                } else {
                    lua += '["' + key + '"] = ';
                }
                if (Array.isArray(value)) {
                    if (value.length > 0 && typeof value[0] === 'object' && value[0].hasOwnProperty('value')) {
                        // Array of objects with value and comment
                        lua += '{\n';
                        value.forEach(function(val) {
                            lua += indent2 + '    ';
                            if (val.key) {
                                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(val.key)) {
                                    lua += val.key + ' = HEX(\'' + val.value + '\'),\n';
                                } else {
                                    lua += '["' + val.key + '"] = HEX(\'' + val.value + '\'),\n';
                                }
                            } else {
                                lua += 'HEX(\'' + val.value + '\'),\n';
                            }
                        });
                        lua += indent2 + '},\n';
                    } else {
                        lua += '{},\n';
                    }
                } else if (typeof value === 'string') {
                    lua += 'HEX(\'' + value + '\'),\n';
                } else {
                    lua += 'nil,\n';
                }
            });
            lua += indent + '}';
            return lua;
        }

        // Corrected Import from Text functionality
        document.getElementById('importTextButton').addEventListener('click', function() {
            const luaCode = document.getElementById('exportLuaOutput').value;
            try {
                const flattenedData = parseLuaPalette(luaCode);
                if (flattenedData) {
                    // Create a new copy of defaultColorData
                    colorData = JSON.parse(JSON.stringify(defaultColorData));
                    // Update colorData with the flattened data
                    updateColorData(colorData, flattenedData);
                    createColorPickers(colorData, document.getElementById('colorContainer'), defaultColorData);
                } else {
                    alert('Failed to import palette. Invalid format.');
                }
            } catch (err) {
                console.error(err);
                alert(`An error occurred while importing the Lua code: ${err.message}`);
            }
        });

            
        // Function to update colorData with the flattened data
        function updateColorData(dataArray, flattenedObj) {
            dataArray.forEach(item => {
                const key = item.key;
                if (flattenedObj.hasOwnProperty(key)) {
                    const value = flattenedObj[key];
                    if (typeof value === 'string') {
                        item.value = value.toUpperCase();
                    }
                } else if (Array.isArray(item.value)) {
                    item.value.forEach((subItem, index) => {
                        let subKey = subItem.key ? `${key}.${subItem.key}` : `${key}[${index}]`;
                        if (flattenedObj.hasOwnProperty(subKey)) {
                            subItem.value = flattenedObj[subKey].toUpperCase();
                        } else if (typeof subItem.value === 'object') {
                            updateNestedColorData(subItem.value, subKey, flattenedObj);
                        }
                    });
                } else if (typeof item.value === 'object') {
                    updateNestedColorData(item.value, key, flattenedObj);
                }
            });
        }
        
        function updateNestedColorData(obj, parentKey, flattenedObj) {
            for (let key in obj) {
                let newKey = `${parentKey}.${key}`;
                if (flattenedObj.hasOwnProperty(newKey)) {
                    obj[key] = flattenedObj[newKey].toUpperCase();
                } else if (typeof obj[key] === 'object') {
                    updateNestedColorData(obj[key], newKey, flattenedObj);
                }
            }
        }


        function parseLuaPalette(luaCode) {
            // Remove comments
            luaCode = luaCode.replace(/--.*$/gm, '');
        
            // Remove 'return' keyword and any leading whitespace
            luaCode = luaCode.replace(/^\s*return\s*/, '');
        
            // Replace function calls like HEX('FFFFFF') with string values
            luaCode = luaCode.replace(/HEX\(['"]([0-9A-Fa-f]{6,8})['"]\)/g, '"$1"');
        
            // Replace single quotes with double quotes
            luaCode = luaCode.replace(/'/g, '"');
        
            // Initialize variables
            let index = 0;
            const length = luaCode.length;
        
            // Function to parse the Lua table
            function parseValue() {
                skipWhitespace();
                if (luaCode[index] === '{') {
                    return parseTable();
                } else if (luaCode[index] === '"') {
                    return parseString();
                } else if (/[a-zA-Z_]/.test(luaCode[index])) {
                    return parseIdentifier();
                } else {
                    return parseLiteral();
                }
            }
        
            function parseTable() {
                let isArray = true;
                const result = [];
                index++; // Skip '{'
                skipWhitespace();
        
                while (index < length && luaCode[index] !== '}') {
                    skipWhitespace();
        
                    // Check for key-value pair
                    let startIdx = index;
                    let key = null;
                    if (luaCode[index] === '"') {
                        key = parseString();
                    } else if (/[a-zA-Z_]/.test(luaCode[index])) {
                        key = parseIdentifier();
                    }
        
                    skipWhitespace();
                    if (luaCode[index] === '=' || luaCode[index] === ':') {
                        // This is a key-value pair
                        isArray = false;
                        index++; // Skip '=' or ':'
                        skipWhitespace();
                        const value = parseValue();
                        result.push({ key, value });
                    } else if (key !== null) {
                        // Not a key-value pair, reset index and treat as value
                        index = startIdx;
                        const value = parseValue();
                        result.push(value);
                    } else {
                        // Parse value directly
                        const value = parseValue();
                        result.push(value);
                    }
        
                    skipWhitespace();
                    if (luaCode[index] === ',') {
                        index++; // Skip ','
                        skipWhitespace();
                    } else {
                        break;
                    }
                }
        
                if (luaCode[index] === '}') {
                    index++; // Skip '}'
                    if (isArray) {
                        return result;
                    } else {
                        const obj = {};
                        result.forEach(item => {
                            if (item.key !== undefined) {
                                obj[item.key] = item.value;
                            } else {
                                throw new Error('Invalid table structure');
                            }
                        });
                        return obj;
                    }
                } else {
                    throw new Error(`Expected '}' at position ${index}`);
                }
            }
        
            function parseIdentifier() {
                let id = '';
                while (index < length && /[a-zA-Z0-9_]/.test(luaCode[index])) {
                    id += luaCode[index++];
                }
                return id;
            }
        
            function parseString() {
                let str = '';
                index++; // Skip opening '"'
                while (index < length && luaCode[index] !== '"') {
                    str += luaCode[index++];
                }
                if (luaCode[index] === '"') {
                    index++; // Skip closing '"'
                    return str;
                } else {
                    throw new Error(`Unterminated string at position ${index}`);
                }
            }
        
            function parseLiteral() {
                let literal = '';
                while (index < length && /[\w\d]/.test(luaCode[index])) {
                    literal += luaCode[index++];
                }
                return literal;
            }
        
            function skipWhitespace() {
                while (index < length && /\s/.test(luaCode[index])) {
                    index++;
                }
            }
        
            // Start parsing
            try {
                const parsedValue = parseValue();
                // Now, we have a JavaScript object representing the Lua table
                let flattened = {};
                flattenObject(parsedValue, '', flattened);
                return flattened;
            } catch (e) {
                console.error('Error parsing Lua code:', e);
                alert(`Failed to parse Lua code: ${e.message}`);
                return null;
            }
        }
        
        // Helper function to flatten the object
        function flattenObject(obj, parentKey, result) {
            if (Array.isArray(obj)) {
                obj.forEach((item, index) => {
                    const newKey = parentKey ? `${parentKey}[${index}]` : `[${index}]`;
                    if (typeof item === 'object' && item !== null) {
                        flattenObject(item, newKey, result);
                    } else {
                        result[newKey] = item;
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                for (let key in obj) {
                    const newKey = parentKey ? `${parentKey}.${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null) {
                        flattenObject(obj[key], newKey, result);
                    } else {
                        result[newKey] = obj[key];
                    }
                }
            }
        }
        
        function flattenColorData(dataArray, parentKey = '', result = {}) {
            dataArray.forEach(item => {
                let currentKey = parentKey ? `${parentKey}.${item.key}` : item.key;
        
                if (Array.isArray(item.value)) {
                    // Check if the array is of objects with 'key' and 'value'
                    if (item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('key')) {
                        // Array of objects with 'key' and 'value'
                        item.value.forEach(subItem => {
                            flattenColorData([subItem], currentKey, result);
                        });
                    } else if (item.value.length > 0 && typeof item.value[0] === 'object' && item.value[0].hasOwnProperty('value')) {
                        // Array of objects with 'value' (no 'key')
                        item.value.forEach((subItem, index) => {
                            let subKey = `${currentKey}[${index}]`;
                            if (typeof subItem.value === 'object') {
                                flattenColorData([subItem], subKey, result);
                            } else {
                                result[subKey] = subItem.value;
                            }
                        });
                    } else {
                        // Array of primitive values
                        item.value.forEach((subValue, index) => {
                            let subKey = `${currentKey}[${index}]`;
                            result[subKey] = subValue;
                        });
                    }
                } else if (typeof item.value === 'object' && item.value !== null) {
                    // Value is an object
                    flattenColorData([item.value], currentKey, result);
                } else {
                    // Value is a string or primitive
                    result[currentKey] = item.value;
                }
            });
        
            return result;
        }
        
        // Function to convert Lua arrays to JSON arrays
        function convertLuaArrays(luaCode) {
            // This function finds tables without keys and converts them to JSON arrays
        
            // Regex pattern to find tables without keys
            const arrayPattern = /{([\s\S]*?)}/g;
        
            return luaCode.replace(arrayPattern, function(match, content) {
                // Check if the content contains any colons, indicating key-value pairs
                if (/:\s*/.test(content)) {
                    // Contains key-value pairs, keep as object
                    return '{' + content + '}';
                } else {
                    // No key-value pairs, convert to array
                    return '[' + content + ']';
                }
            });
        }
        
        function parseTable(tableNode) {
            const table = {};
        
            tableNode.fields.forEach(field => {
                if (field.type === 'TableKey' || field.type === 'TableKeyString') {
                    const key = parseExpression(field.key);
                    const value = parseExpression(field.value);
                    table[key] = value;
                } else if (field.type === 'TableValue') {
                    // Handle array entries
                    const value = parseExpression(field.value);
                    if (!Array.isArray(table.array)) {
                        table.array = [];
                    }
                    table.array.push(value);
                }
            });
        
            return table;
        }
        
        function parseExpression(node) {
            switch (node.type) {
                case 'StringLiteral':
                    return node.value;
                case 'NumericLiteral':
                    return node.value;
                case 'BooleanLiteral':
                    return node.value;
                case 'TableConstructorExpression':
                    return parseTable(node);
                case 'CallExpression':
                    return parseFunctionCall(node);
                case 'Identifier':
                    return node.name;
                default:
                    return null;
            }
        }
        
        function parseFunctionCall(node) {
            // Assuming function calls are like HEX('FFFFFF')
            if (node.base.type === 'Identifier' && node.base.name === 'HEX') {
                const arg = node.arguments[0];
                if (arg.type === 'StringLiteral') {
                    return arg.value.toUpperCase();
                }
            }
            return null;
        }
        
        // Add the scroll event listener to show/hide the "Top" button
        window.onscroll = function() { scrollFunction(); };
        
        function scrollFunction() {
            const scrollTopButton = document.getElementById("scrollTopButton");
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                scrollTopButton.style.display = "block";
            } else {
                scrollTopButton.style.display = "none";
            }
        }
        
        // "Jump to Top" button functionality
        document.getElementById('scrollTopButton').addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        // Function to lookup color by key
        function lookupColorByKey(keyPath, useDefault = false) {
            let dataArray = useDefault ? defaultColorData : colorData;
            let flattenedData = flattenColorData(dataArray);
        
            if (flattenedData.hasOwnProperty(keyPath)) {
                return flattenedData[keyPath];
            } else {
                return null;
            }
        }
        
        // Recursive function to find color in data array
        function findColorInDataArray(dataArray, key) {
            for (let item of dataArray) {
                if (item.key && item.key.toUpperCase() === key) {
                    if (typeof item.value === 'string') {
                        return item.value;
                    } else if (Array.isArray(item.value)) {
                        // If the value is an array, you might decide how to handle it
                        // For simplicity, return null or handle nested keys
                        continue;
                    }
                } else if (Array.isArray(item.value)) {
                    // Check within nested arrays
                    let result = findColorInValueArray(item.value, key);
                    if (result) {
                        return result;
                    }
                }
            }
            return null;
        }
        
        // Function to find color in value array
        function findColorInValueArray(valueArray, key) {
            for (let val of valueArray) {
                if (val.key && val.key.toUpperCase() === key) {
                    if (typeof val.value === 'string') {
                        return val.value;
                    }
                }
            }
            return null;
        }
        
        // Function to check if a key exists
        function doesKeyExist(keyPath) {
            return lookupColorByKey(keyPath, true) !== null || lookupColorByKey(keyPath, false) !== null;
        }
        
        function parseKeyPath(keyPath) {
            // Split by '.' to separate nested keys
            let parts = keyPath.split('.');
            let keys = [];
            for (let part of parts) {
                // Handle indices in square brackets
                let regex = /([^\[|\]]+)(\[\d+\])*/g;
                let match;
                while ((match = regex.exec(part)) !== null) {
                    let key = match[1];
                    keys.push(key);
                    if (match[2]) {
                        let indices = match[2].match(/\d+/g).map(Number);
                        keys.push(...indices);
                    }
                }
            }
            return keys.length > 0 ? keys : null;
        }

        function findColorByKeyPath(data, keys) {
            if (!data || keys.length === 0) {
                if (typeof data === 'object' && data.value && typeof data.value === 'string') {
                    return data.value;
                }
                return null;
            }
        
            let key = keys[0];
            let remainingKeys = keys.slice(1);
        
            if (Array.isArray(data)) {
                if (typeof key === 'number') {
                    // Key is an index
                    if (data[key]) {
                        return findColorByKeyPath(data[key], remainingKeys);
                    } else {
                        return null;
                    }
                } else {
                    // Key is a string, find object with matching key
                    for (let item of data) {
                        if (item.key === key) {
                            return findColorByKeyPath(item, remainingKeys);
                        }
                    }
                    return null;
                }
            } else if (typeof data === 'object') {
                if (data.key === key) {
                    if (remainingKeys.length === 0 && typeof data.value === 'string') {
                        // Found the color value
                        return data.value;
                    } else if (data.value) {
                        return findColorByKeyPath(data.value, remainingKeys);
                    }
                } else if (data.value && typeof data.value === 'object') {
                    return findColorByKeyPath(data.value, keys);
                }
            }
            return null;
        }
    </script>
</body>
</html>
